# 5x5 Pegged Polyomino Puzzle — Problem and Solution Plan

## Problem overview

- **Board**: 5×5 grid using 0-based coordinates where x grows to the right and y grows downward. Valid cells: x ∈ [0,4], y ∈ [0,4].
- **Pegs**: Exactly three blocked cells; pieces may not occupy these coordinates.
  - Placement restrictions by domain (generalized):
    - Domains:
      1. D0 = [(1,0),(0,0),(0,1),(0,2),(0,3),(0,4),(0,5)]
      2. D1 = [(1,2),(2,2),(2,3),(2,4),(3,4),(4,4),(4,3)]
      3. D2 = [(1,1),(2,1),(3,1),(3,2),(3,3),(4,1),(4,0),(3,0)]
    - Rule: exactly one peg must appear in each domain; any peg can occupy any domain (no fixed peg→domain mapping). For a 5×5 board, out-of-bounds coordinates (e.g., (0,5)) are ignored from the domain sets.
- **Pieces** (given as unit-offsets from their local origin (0,0)):
  - **short_l**: [(0,0), (1,0), (0,1)]
  - **long_l**: [(0,0), (1,0), (2,0), (0,1)]
  - **square**: [(0,0), (1,0), (0,1), (1,1)]
  - **zig**: [(0,0), (0,1), (1,1), (2,1)]
  - **bar**: [(0,0), (0,1), (0,2)]
  - **triangle**: [(0,0), (0,1), (1,1), (0,2)]
- **Goal**: Place all 6 pieces so they cover every non-pegged cell exactly once (no overlaps, no out-of-bounds, no coverage of a peg). Rotations and flips are allowed.

## Coordinate and geometry conventions

- **Global coordinates**: (x, y) with origin at the top-left of the board.
- **Piece orientation**: Generated by up to 8 transforms: rotate 0/90/180/270°, with and without horizontal flip. Normalize each transformed shape by translating so its minimum x and y are 0, then deduplicate by shape set-equality to get unique orientations.
- **Placement**: Choose an orientation and a global origin (ox, oy). The occupied global cells are {(ox + dx, oy + dy) for (dx, dy) in the orientation}. A placement is valid if all cells are inside the 5×5 board, do not overlap pegs, and do not collide with already-placed cells.

## Data I/O (v1: simple, data-only)

- **Input** (JSON or YAML) — pegs only; pieces are fixed:

```json
{
  "board_size": 5,
  "pegs": [[1,0], [3,2], [4,4]]
}
```

- **Output** (JSON) — a single solution with concrete placements. Represent orientation by an index into the unique-orientations list for that piece.

```json
{
  "solution": {
    "placements": [
      {
        "piece": "square",
        "origin": [2,1],
        "orientation_index": 0,
        "cells": [[2,1],[3,1],[2,2],[3,2]]
      }
      // ... one entry per piece ...
    ]
  }
}
```

- If no solution exists, return `{ "solution": null }` or `{ "error": "no_solution" }`.

## Minimal CLI (v1)

- **Command**: `bin/solve --pegs "x1,y1 x2,y2 x3,y3"`
- **Behavior**: Parses pegs, runs solver, prints JSON to stdout.
- **Example**:

```bash
bin/solve --pegs "1,0 3,2 4,4"
```

- On invalid pegs per the domain rule, the CLI exits non-zero and prints a JSON error with a message and the domain sets.

## Solver approach

- **Phase 1 (v1: backtracking with pruning)**
  1. Precompute unique orientations for each piece.
  2. Maintain a 5×5 occupancy bitmap and a set of remaining pieces.
  3. Choose the next board cell to fill using a heuristic (e.g., the lexicographically smallest empty cell, or better: the most constrained empty cell w.r.t. possible placements).
  4. For each remaining piece, iterate its orientations and all feasible origins that cover the target cell; try valid placements; recurse.
  5. Backtrack on conflicts; stop at first full tiling or enumerate all solutions if desired.

- **Key pruning heuristics**
  - **Next-cell heuristic**: pick the empty cell with the fewest candidate placements (fail-fast).
  - **Orientation deduplication**: precompute canonical shapes so the solver never retries symmetrically identical orientations.
  - **Piece ordering**: try pieces with fewer orientations/placements first.
  - **Connectivity check (optional)**: ensure uncovered cells remain in components that are tileable given remaining piece areas; a light version is to prune when any uncovered region has size not divisible by the GCD of remaining piece cell-counts (often 1 here, so this is optional).

- **Phase 2 (optional upgrade: exact cover / DLX)**
  - Model as Exact Cover with columns = {board cells to cover} ∪ {piece-usage constraints} and rows = all valid placements of a single piece covering specific cells.
  - Solve with Algorithm X / Dancing Links for speed and clean solution enumeration.

## Piece orientation details (dedup examples)

- **square**: 1 unique orientation (all transforms identical).
- **bar**: 2 unique orientations (vertical vs horizontal).
- **short_l**, **long_l**, **zig**, **triangle**: up to 8, but many collapse; compute programmatically.

## Data structures

- **Piece**: name, base_cells (Array[[dx,dy]]), orientations (Array[Array[[dx,dy]]]).
- **Board**: size (5), pegs (Set[[x,y]]), occupied (Bitset or Set[[x,y]]).
- **Placement**: piece_name, origin [x,y], orientation_index, cells (derived).

## File layout (proposed)

- `bin/solve` — CLI entry (reads pegs, prints JSON solution)
- `lib/piece_solver/piece.rb` — base piece and orientation utilities
- `lib/piece_solver/board.rb` — board representation and validation helpers
- `lib/piece_solver/solver.rb` — backtracking solver (v1)
- `spec/` — unit tests (pieces, orientation counts, simple solvable boards)

## Milestones

- **M1**: Enumerate unique orientations for all pieces; unit tests for counts.
- **M2**: Implement backtracking solver that finds one solution; CLI prints JSON.
- **M3**: Add solution enumeration and basic performance sanity checks.
- **M4 (optional)**: Switch to / add DLX solver; benchmark.
- **M5 (optional)**: Graphical output (e.g., SVG) based on `placements` data.

## Example peg sets for testing

- **Nominal**: [[1,0],[3,2],[4,4]]
- **Clustered**: [[1,1],[1,2],[2,1]]
- **Edges**: [[0,0],[4,0],[2,4]]
- For tests, assert solver returns a solution (or none for intentionally impossible arrangements if you add such cases).

## Notes on determinism and reproducibility

- Fix iteration orders (piece order, orientation order, origin order) or seed any randomized tiebreakers to make outputs deterministic for tests.

## Next steps (after v1)

- Add `--all` to enumerate all solutions.
- Add `--format svg` to emit a simple vector drawing.
- Add `--time` to print runtime/branch stats for tuning.
